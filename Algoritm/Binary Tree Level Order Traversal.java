// Time Complexity : O(n)
// Space Complexity : O(n)
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        // Create an array list to store the output result...
        List<List<Integer>> output = new ArrayList<>();
        // Base case: If the tree is empty...
		if (root == null)  return output;
	    // Initialize a queue to store the nodes on the same level & add root in it...
		LinkedList<TreeNode> q = new LinkedList<TreeNode>();
		q.add(root);
        // Traverse a loop untill the queue becomes empty...
		while (!q.isEmpty()) {
            // Denotes the number of elements on that level...
            int size = q.size();
            // A temporary list to store all the left and right child for all the node in the level...
			ArrayList<Integer> temp = new ArrayList<>(size);
			for (int idx = 0; idx < size ; idx++) {
                // Initialize a treenode as the popped element of the queue & store the value of the new treenode to temp...
				TreeNode node = q.remove();
				temp.add(node.val);
                // Store all the nodes of next level...
                // Add left and right child if they are not None...
				if (node.left != null)
					q.add(node.left);
				if (node.right != null)
					q.add(node.right);
			}
            // Add the temp to output result...
			output.add(temp);
		}
		return output;       // Return the output result...
    }
}
